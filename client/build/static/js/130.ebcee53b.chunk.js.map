{"version":3,"sources":["../node_modules/ace-builds/src-noconflict/mode-ruby.js"],"names":["ace","define","require","exports","module","oop","TextHighlightRules","constantOtherSymbol","token","regex","qString","qqString","tString","constantNumericHex","constantNumericBinary","constantNumericDecimal","constantNumericOctal","constantNumericRational","constantNumericComplex","constantNumericFloat","instanceVariable","RubyHighlightRules","keywordMapper","this","$keywords","createKeywordMapper","escapedChars","closeParen","$rules","next","push","defaultToken","onMatch","val","state","stack","length","paren","unshift","stateName","value","currentState","tokens","split","splitRegex","type","rules","heredoc","shift","indentedHeredoc","include","normalizeRules","inherits","Range","MatchingBraceOutdent","checkOutdent","line","input","test","autoOutdent","doc","row","match","getLine","column","openBracePos","findMatchingBracket","indent","$getIndent","replace","call","prototype","BaseFoldMode","FoldMode","TokenIterator","indentKeywords","foldingStartMarker","foldingStopMarker","getFoldWidget","session","foldStyle","isStart","isEnd","getTokenAt","index","getFoldWidgetRange","exec","rubyBlock","openingBracketBlock","closingBracketBlock","tokenRange","stream","getCurrentToken","RegExp","dir","startColumn","startRow","ranges","getCurrentTokenRange","step","stepBackward","stepForward","ignore","level","getCurrentTokenRow","i","$tokenIndex","prevToken","$rowTokens","endColumn","TextMode","Mode","CstyleBehaviour","HighlightRules","$outdent","$behaviour","foldingRules","lineCommentStart","getNextLineIndent","tab","getTokenizer","getLineTokens","startingClassOrMethod","startingDoBlock","startingConditional","prevLine","prevIndent","getTabString","slice","remove","getMatching","undefined","pos","selection","lead","startToken","$id","snippetFileId","m"],"mappings":"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","file":"static/js/130.ebcee53b.chunk.js","sourcesContent":["ace.define(\"ace/mode/ruby_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar constantOtherSymbol = exports.constantOtherSymbol = {\n    token : \"constant.other.symbol.ruby\", // symbol\n    regex : \"[:](?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?\"\n};\n\nexports.qString = {\n    token : \"string\", // single line\n    regex : \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n};\n\nexports.qqString = {\n    token : \"string\", // single line\n    regex : '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n};\n\nexports.tString = {\n    token : \"string\", // backtick string\n    regex : \"[`](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[`]\"\n};\n\nvar constantNumericHex = exports.constantNumericHex = {\n    token : \"constant.numeric\", // hex\n    regex : \"0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_(?=[0-9a-fA-F]))*\\\\b\"\n};\n\nvar constantNumericBinary = exports.constantNumericBinary = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[bB][01](?:[01]|_(?=[01]))*)\\b/\n};\n\nvar constantNumericDecimal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[dD](?:[1-9](?:[\\d]|_(?=[\\d]))*|0))\\b/\n};\n\nvar constantNumericOctal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[oO]?(?:[1-7](?:[0-7]|_(?=[0-7]))*|0))\\b/\n};\n\nvar constantNumericRational = exports.constantNumericRational = {\n    token: \"constant.numeric\", //rational + complex\n    regex: /\\b([\\d]+(?:[./][\\d]+)?ri?)\\b/\n};\n\nvar constantNumericComplex = exports.constantNumericComplex = {\n    token: \"constant.numeric\", //simple complex numbers\n    regex: /\\b([\\d]i)\\b/\n};\n\nvar constantNumericFloat = exports.constantNumericFloat = {\n    token : \"constant.numeric\", // float + complex\n    regex : \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?i?\\\\b\"\n};\n\nvar instanceVariable = exports.instanceVariable = {\n    token : \"variable.instance\", // instance variable\n    regex : \"@{1,2}[a-zA-Z_\\\\d]+\"\n};\n\nvar RubyHighlightRules = function() {\n\n    var builtinFunctions = (\n        \"abort|Array|assert|assert_equal|assert_not_equal|assert_same|assert_not_same|\" +\n        \"assert_nil|assert_not_nil|assert_match|assert_no_match|assert_in_delta|assert_throws|\" +\n        \"assert_raise|assert_nothing_raised|assert_instance_of|assert_kind_of|assert_respond_to|\" +\n        \"assert_operator|assert_send|assert_difference|assert_no_difference|assert_recognizes|\" +\n        \"assert_generates|assert_response|assert_redirected_to|assert_template|assert_select|\" +\n        \"assert_select_email|assert_select_rjs|assert_select_encoded|css_select|at_exit|\" +\n        \"attr|attr_writer|attr_reader|attr_accessor|attr_accessible|autoload|binding|block_given?|callcc|\" +\n        \"caller|catch|chomp|chomp!|chop|chop!|defined?|delete_via_redirect|eval|exec|exit|\" +\n        \"exit!|fail|Float|flunk|follow_redirect!|fork|form_for|form_tag|format|gets|global_variables|gsub|\" +\n        \"gsub!|get_via_redirect|host!|https?|https!|include|Integer|lambda|link_to|\" +\n        \"link_to_unless_current|link_to_function|link_to_remote|load|local_variables|loop|open|open_session|\" +\n        \"p|print|printf|proc|putc|puts|post_via_redirect|put_via_redirect|raise|rand|\" +\n        \"raw|readline|readlines|redirect?|request_via_redirect|require|scan|select|\" +\n        \"set_trace_func|sleep|split|sprintf|srand|String|stylesheet_link_tag|syscall|system|sub|sub!|test|\" +\n        \"throw|trace_var|trap|untrace_var|atan2|cos|exp|frexp|ldexp|log|log10|sin|sqrt|tan|\" +\n        \"render|javascript_include_tag|csrf_meta_tag|label_tag|text_field_tag|submit_tag|check_box_tag|\" +\n        \"content_tag|radio_button_tag|text_area_tag|password_field_tag|hidden_field_tag|\" +\n        \"fields_for|select_tag|options_for_select|options_from_collection_for_select|collection_select|\" +\n        \"time_zone_select|select_date|select_time|select_datetime|date_select|time_select|datetime_select|\" +\n        \"select_year|select_month|select_day|select_hour|select_minute|select_second|file_field_tag|\" +\n        \"file_field|respond_to|skip_before_filter|around_filter|after_filter|verify|\" +\n        \"protect_from_forgery|rescue_from|helper_method|redirect_to|before_filter|\" +\n        \"send_data|send_file|validates_presence_of|validates_uniqueness_of|validates_length_of|\" +\n        \"validates_format_of|validates_acceptance_of|validates_associated|validates_exclusion_of|\" +\n        \"validates_inclusion_of|validates_numericality_of|validates_with|validates_each|\" +\n        \"authenticate_or_request_with_http_basic|authenticate_or_request_with_http_digest|\" +\n        \"filter_parameter_logging|match|get|post|resources|redirect|scope|assert_routing|\" +\n        \"translate|localize|extract_locale_from_tld|caches_page|expire_page|caches_action|expire_action|\" +\n        \"cache|expire_fragment|expire_cache_for|observe|cache_sweeper|\" +\n        \"has_many|has_one|belongs_to|has_and_belongs_to_many|p|warn|refine|using|module_function|extend|alias_method|\" +\n        \"private_class_method|remove_method|undef_method\"\n    );\n\n    var keywords = (\n        \"alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|\" +\n        \"__FILE__|finally|for|gem|if|in|__LINE__|module|next|not|or|private|protected|public|\" +\n        \"redo|rescue|retry|return|super|then|undef|unless|until|when|while|yield|__ENCODING__|prepend\"\n    );\n\n    var buildinConstants = (\n        \"true|TRUE|false|FALSE|nil|NIL|ARGF|ARGV|DATA|ENV|RUBY_PLATFORM|RUBY_RELEASE_DATE|\" +\n        \"RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING|RUBY_PATCHLEVEL|RUBY_REVISION|RUBY_COPYRIGHT|RUBY_ENGINE|RUBY_ENGINE_VERSION|RUBY_DESCRIPTION\"\n    );\n\n    var builtinVariables = (\n        \"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" +\n        \"$!|root_url|flash|session|cookies|params|request|response|logger|self\"\n    );\n\n    var keywordMapper = this.$keywords = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"constant.language\": buildinConstants,\n        \"variable.language\": builtinVariables,\n        \"support.function\": builtinFunctions,\n        \"invalid.deprecated\": \"debugger\" // TODO is this a remnant from js mode?\n    }, \"identifier\");\n\n    var escapedChars = \"\\\\\\\\(?:n(?:[1-7][0-7]{0,2}|0)|[nsrtvfbae'\\\"\\\\\\\\]|c(?:\\\\\\\\M-)?.|M-(?:\\\\\\\\C-|\\\\\\\\c)?.|C-(?:\\\\\\\\M-)?.|[0-7]{3}|x[\\\\da-fA-F]{2}|u[\\\\da-fA-F]{4}|u{[\\\\da-fA-F]{1,6}(?:\\\\s[\\\\da-fA-F]{1,6})*})\";\n\n    var closeParen = {\n        \"(\": \")\",\n        \"[\": \"]\",\n        \"{\": \"}\",\n        \"<\": \">\",\n        \"^\": \"^\",\n        \"|\": \"|\",\n        \"%\": \"%\"\n    };\n\n    this.$rules = {\n        \"start\": [\n            {\n                token: \"comment\",\n                regex: \"#.*$\"\n            }, {\n                token: \"comment.multiline\", // multi line comment\n                regex: \"^=begin(?=$|\\\\s.*$)\",\n                next: \"comment\"\n            }, {\n                token: \"string.regexp\",\n                regex: /[/](?=.*\\/)/,\n                next: \"regex\"\n            },\n\n            [{\n                token: [\"constant.other.symbol.ruby\", \"string.start\"],\n                regex: /(:)?(\")/,\n                push: [{\n                    token: \"constant.language.escape\",\n                    regex: escapedChars\n                }, {\n                    token: \"paren.start\",\n                    regex: /#{/,\n                    push: \"start\"\n                }, {\n                    token: \"string.end\",\n                    regex: /\"/,\n                    next: \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }, {\n                token: \"string.start\",\n                regex: /`/,\n                push: [{\n                    token: \"constant.language.escape\",\n                    regex: escapedChars\n                }, {\n                    token: \"paren.start\",\n                    regex: /#{/,\n                    push: \"start\"\n                }, {\n                    token: \"string.end\",\n                    regex: /`/,\n                    next: \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }, {\n                token: [\"constant.other.symbol.ruby\", \"string.start\"],\n                regex: /(:)?(')/,\n                push: [{\n                    token: \"constant.language.escape\",\n                    regex: /\\\\['\\\\]/\n                }, {\n                    token: \"string.end\",\n                    regex: /'/,\n                    next: \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }, {\n                token: \"string.start\",//doesn't see any differences between strings and array of strings in highlighting\n                regex: /%[qwx]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"qStateWithoutInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"string.start\", //doesn't see any differences between strings and array of strings in highlighting\n                regex: /%[QWX]?([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"qStateWithInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"constant.other.symbol.ruby\", //doesn't see any differences between symbols and array of symbols in highlighting\n                regex: /%[si]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"sStateWithoutInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"constant.other.symbol.ruby\", //doesn't see any differences between symbols and array of symbols in highlighting\n                regex: /%[SI]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"sStateWithInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"string.regexp\",\n                regex: /%[r]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"rState\";\n                    return this.token;\n                }\n            }],\n\n            {\n                token: \"punctuation\", // namespaces aren't symbols\n                regex: \"::\"\n            },\n            instanceVariable,\n            {\n                token: \"variable.global\", // global variable\n                regex: \"[$][a-zA-Z_\\\\d]+\"\n            }, {\n                token: \"support.class\", // class name\n                regex: \"[A-Z][a-zA-Z_\\\\d]*\"\n            }, {\n                token: [\"punctuation.operator\", \"support.function\"],\n                regex: /(\\.)([a-zA-Z_\\d]+)(?=\\()/\n            }, {\n                token: [\"punctuation.operator\", \"identifier\"],\n                regex: /(\\.)([a-zA-Z_][a-zA-Z_\\d]*)/\n            }, {\n                token: \"string.character\",\n                regex: \"\\\\B\\\\?(?:\" + escapedChars + \"|\\\\S)\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: /\\?(?=.+:)/\n            },\n\n            constantNumericRational,\n            constantNumericComplex,\n            constantOtherSymbol,\n            constantNumericHex,\n            constantNumericFloat,\n            constantNumericBinary,\n            constantNumericDecimal,\n            constantNumericOctal,\n            {\n                token: \"constant.language.boolean\",\n                regex: \"(?:true|false)\\\\b\"\n            }, {\n                token: keywordMapper,\n                regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n            }, {\n                token: \"punctuation.separator.key-value\",\n                regex: \"=>\"\n            }, {\n                stateName: \"heredoc\",\n                onMatch: function (value, currentState, stack) {\n                    var next = (value[2] == '-' || value[2] == '~') ? \"indentedHeredoc\" : \"heredoc\";\n                    var tokens = value.split(this.splitRegex);\n                    stack.push(next, tokens[3]);\n                    return [\n                        {type: \"constant\", value: tokens[1]},\n                        {type: \"string\", value: tokens[2]},\n                        {type: \"support.class\", value: tokens[3]},\n                        {type: \"string\", value: tokens[4]}\n                    ];\n                },\n                regex: \"(<<[-~]?)(['\\\"`]?)([\\\\w]+)(['\\\"`]?)\",\n                rules: {\n                    heredoc: [{\n                        onMatch: function(value, currentState, stack) {\n                            if (value === stack[1]) {\n                                stack.shift();\n                                stack.shift();\n                                this.next = stack[0] || \"start\";\n                                return \"support.class\";\n                            }\n                            this.next = \"\";\n                            return \"string\";\n                        },\n                        regex: \".*$\",\n                        next: \"start\"\n                    }],\n                    indentedHeredoc: [{\n                        token: \"string\",\n                        regex: \"^ +\"\n                    }, {\n                        onMatch: function(value, currentState, stack) {\n                            if (value === stack[1]) {\n                                stack.shift();\n                                stack.shift();\n                                this.next = stack[0] || \"start\";\n                                return \"support.class\";\n                            }\n                            this.next = \"\";\n                            return \"string\";\n                        },\n                        regex: \".*$\",\n                        next: \"start\"\n                    }]\n                }\n            }, {\n                regex: \"$\",\n                token: \"empty\",\n                next: function(currentState, stack) {\n                    if (stack[0] === \"heredoc\" || stack[0] === \"indentedHeredoc\")\n                        return stack[0];\n                    return currentState;\n                }\n            },  {\n                token: \"keyword.operator\",\n                regex: \"!|\\\\$|%|&|\\\\*|/|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\||\\\\b(?:in|instanceof|new|delete|typeof|void)\"\n            }, {\n                token: \"paren.lparen\",\n                regex: \"[[({]\"\n            }, {\n                token: \"paren.rparen\",\n                regex: \"[\\\\])}]\",\n                onMatch: function(value, currentState, stack) {\n                    this.next = '';\n                    if (value == \"}\" && stack.length > 1 && stack[1] != \"start\") {\n                        stack.shift();\n                        this.next = stack.shift();\n                    }\n                    return this.token;\n                }\n            }, {\n                token: \"text\",\n                regex: \"\\\\s+\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: /[?:,;.]/\n            }\n        ],\n        \"comment\": [\n            {\n                token: \"comment.multiline\", // closing comment\n                regex: \"^=end(?=$|\\\\s.*$)\",\n                next: \"start\"\n            }, {\n                token: \"comment\", // comment spanning whole line\n                regex: \".+\"\n            }\n        ],\n        \"qStateWithInterpolation\": [{\n            token: \"string.start\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"string\";\n            }\n        }, {\n            token: \"constant.language.escape\",\n            regex: escapedChars\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\./\n        }, {\n            token: \"paren.start\",\n            regex: /#{/,\n            push: \"start\"\n        }, {\n            token: \"string.end\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"string\";\n            }\n        }, {\n            defaultToken: \"string\"\n        }],\n        \"qStateWithoutInterpolation\": [{\n            token: \"string.start\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"string\";\n            }\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\['\\\\]/\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\./\n        }, {\n            token: \"string.end\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"string\";\n            }\n        }, {\n            defaultToken: \"string\"\n        }],\n        \"sStateWithoutInterpolation\": [{\n            token: \"constant.other.symbol.ruby\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            token: \"constant.other.symbol.ruby\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            defaultToken: \"constant.other.symbol.ruby\"\n        }],\n        \"sStateWithInterpolation\": [{\n            token: \"constant.other.symbol.ruby\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            token: \"constant.language.escape\",\n            regex: escapedChars\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\./\n        }, {\n            token: \"paren.start\",\n            regex: /#{/,\n            push: \"start\"\n        }, {\n            token: \"constant.other.symbol.ruby\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            defaultToken: \"constant.other.symbol.ruby\"\n        }],\n        \"rState\": [{\n            token: \"string.regexp\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"constant.language.escape\";\n            }\n        }, {\n            token: \"paren.start\",\n            regex: /#{/,\n            push: \"start\"\n        }, {\n            token: \"string.regexp\",\n            regex: /\\//\n        }, {\n            token: \"string.regexp\",\n            regex: /[)\\]>}^|%][imxouesn]*/, onMatch: function (val, state, stack) {\n                if (stack.length && val[0] === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"constant.language.escape\";\n            }\n        },\n            {include: \"regex\"},\n            {\n                defaultToken: \"string.regexp\"\n            }],\n        \"regex\": [\n            {// character classes\n                token: \"regexp.keyword\",\n                regex: /\\\\[wWdDhHsS]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\[AGbBzZ]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\g<[a-zA-Z0-9]*>/\n            }, {\n                token: [\"constant.language.escape\", \"regexp.keyword\", \"constant.language.escape\"],\n                regex: /(\\\\p{\\^?)(Alnum|Alpha|Blank|Cntrl|Digit|Graph|Lower|Print|Punct|Space|Upper|XDigit|Word|ASCII|Any|Assigned|Arabic|Armenian|Balinese|Bengali|Bopomofo|Braille|Buginese|Buhid|Canadian_Aboriginal|Carian|Cham|Cherokee|Common|Coptic|Cuneiform|Cypriot|Cyrillic|Deseret|Devanagari|Ethiopic|Georgian|Glagolitic|Gothic|Greek|Gujarati|Gurmukhi|Han|Hangul|Hanunoo|Hebrew|Hiragana|Inherited|Kannada|Katakana|Kayah_Li|Kharoshthi|Khmer|Lao|Latin|Lepcha|Limbu|Linear_B|Lycian|Lydian|Malayalam|Mongolian|Myanmar|New_Tai_Lue|Nko|Ogham|Ol_Chiki|Old_Italic|Old_Persian|Oriya|Osmanya|Phags_Pa|Phoenician|Rejang|Runic|Saurashtra|Shavian|Sinhala|Sundanese|Syloti_Nagri|Syriac|Tagalog|Tagbanwa|Tai_Le|Tamil|Telugu|Thaana|Thai|Tibetan|Tifinagh|Ugaritic|Vai|Yi|Ll|Lm|Lt|Lu|Lo|Mn|Mc|Me|Nd|Nl|Pc|Pd|Ps|Pe|Pi|Pf|Po|No|Sm|Sc|Sk|So|Zs|Zl|Zp|Cc|Cf|Cn|Co|Cs|N|L|M|P|S|Z|C)(})/\n            }, {\n                token: [\"constant.language.escape\", \"invalid\", \"constant.language.escape\"],\n                regex: /(\\\\p{\\^?)([^/]*)(})/\n            }, {// escapes\n                token: \"regexp.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {// flag\n                token: \"string.regexp\",\n                regex: /[/][imxouesn]*/,\n                next: \"start\"\n            }, {// invalid operators\n                token: \"invalid\",\n                regex: /\\{\\d+\\b,?\\d*\\}[+*]|[+*$^?][+*]|[$^][?]|\\?{3,}/\n            }, {// operators\n                token: \"constant.language.escape\",\n                regex: /\\(\\?(?:[:=!>]|<'?[a-zA-Z]*'?>|<[=!])|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n            }, {\n                token: \"constant.language.delimiter\",\n                regex: /\\|/\n            }, {\n                token: \"regexp.keyword\",\n                regex: /\\[\\[:(?:alnum|alpha|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit|word|ascii):\\]\\]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\[\\^?/,\n                push: \"regex_character_class\"\n            }, {\n                defaultToken: \"string.regexp\"\n            }\n        ],\n        \"regex_character_class\": [\n            {\n                token: \"regexp.keyword\",\n                regex: /\\\\[wWdDhHsS]/\n            }, {\n                token: \"regexp.charclass.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: /&?&?\\[\\^?/,\n                push: \"regex_character_class\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"]\",\n                next: \"pop\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"-\"\n            }, {\n                defaultToken: \"string.regexp.characterclass\"\n            }\n        ]\n    };\n\n    this.normalizeRules();\n};\n\noop.inherits(RubyHighlightRules, TextHighlightRules);\n\nexports.RubyHighlightRules = RubyHighlightRules;\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\n\nace.define(\"ace/mode/folding/ruby\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"], function (require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\n\nvar FoldMode = exports.FoldMode = function () {\n};\n\noop.inherits(FoldMode, BaseFoldMode);\n\n(function () {\n    this.indentKeywords = {\n        \"class\": 1,\n        \"def\": 1,\n        \"module\": 1,\n        \"do\": 1,\n        \"unless\": 1,\n        \"if\": 1,\n        \"while\": 1,\n        \"for\": 1,\n        \"until\": 1,\n        \"begin\": 1,\n        \"else\": 0,\n        \"elsif\": 0,\n        \"rescue\": 0,\n        \"ensure\": 0,\n        \"when\": 0,\n        \"end\": -1,\n        \"case\": 1,\n        \"=begin\": 1,\n        \"=end\": -1\n    };\n\n    this.foldingStartMarker = /(?:\\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\\b|({\\s*$)|(=begin)/;\n    this.foldingStopMarker = /(=end(?=$|\\s.*$))|(^\\s*})|\\b(end)\\b/;\n\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n\n        if (isStart && !isEnd) {\n            var match = line.match(this.foldingStartMarker);\n            if (match[1]) {\n                if (match[1] == \"if\" || match[1] == \"else\" || match[1] == \"while\" || match[1] == \"until\" || match[1] == \"unless\") {\n                    if (match[1] == \"else\" && /^\\s*else\\s*$/.test(line) === false) {\n                        return;\n                    }\n                    if (/^\\s*(?:if|else|while|until|unless)\\s*/.test(line) === false) {\n                        return;\n                    }\n                }\n\n                if (match[1] == \"when\") {\n                    if (/\\sthen\\s/.test(line) === true) {\n                        return;\n                    }\n                }\n                if (session.getTokenAt(row, match.index + 2).type === \"keyword\")\n                    return \"start\";\n            } else if (match[3]) {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return \"start\";\n            } else {\n                return \"start\";\n            }\n        }\n        if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd)\n            return \"\";\n\n        var match = line.match(this.foldingStopMarker);\n        if (match[3] === \"end\") {\n            if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                return \"end\";\n        } else if (match[1]) {\n            if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                return \"end\";\n        } else\n            return \"end\";\n    };\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1] || match[3])\n                return this.rubyBlock(session, row, match.index + 2);\n\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[3] === \"end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n\n            if (match[1] === \"=end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n\n    this.rubyBlock = function (session, row, column, tokenRange) {\n        var stream = new TokenIterator(session, row, column);\n\n        var token = stream.getCurrentToken();\n        if (!token || (token.type != \"keyword\" && token.type != \"comment.multiline\"))\n            return;\n\n        var val = token.value;\n        var line = session.getLine(row);\n        switch (token.value) {\n            case \"if\":\n            case \"unless\":\n            case \"while\":\n            case \"until\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = this.indentKeywords[val];\n                break;\n            case \"when\":\n                if (/\\sthen\\s/.test(line)) {\n                    return;\n                }\n            case \"elsif\":\n            case \"rescue\":\n            case \"ensure\":\n                var dir = 1;\n                break;\n            case \"else\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = 1;\n                break;\n            default:\n                var dir = this.indentKeywords[val];\n                break;\n        }\n\n        var stack = [val];\n        if (!dir)\n            return;\n\n        var startColumn = dir === -1 ? session.getLine(row - 1).length : session.getLine(row).length;\n        var startRow = row;\n        var ranges = [];\n        ranges.push(stream.getCurrentTokenRange());\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        if (token.type == \"comment.multiline\") {\n            while (token = stream.step()) {\n                if (token.type !== \"comment.multiline\")\n                    continue;\n                if (dir == 1) {\n                    startColumn = 6;\n                    if (token.value == \"=end\") {\n                        break;\n                    }\n                } else {\n                    if (token.value == \"=begin\") {\n                        break;\n                    }\n                }\n            }\n        } else {\n            while (token = stream.step()) {\n                var ignore = false;\n                if (token.type !== \"keyword\")\n                    continue;\n                var level = dir * this.indentKeywords[token.value];\n                line = session.getLine(stream.getCurrentTokenRow());\n                switch (token.value) {\n                    case \"do\":\n                        for (var i = stream.$tokenIndex - 1; i >= 0; i--) {\n                            var prevToken = stream.$rowTokens[i];\n                            if (prevToken && (prevToken.value == \"while\" || prevToken.value == \"until\" || prevToken.value == \"for\")) {\n                                level = 0;\n                                break;\n                            }\n                        }\n                        break;\n                    case \"else\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                        if (!checkToken.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"if\":\n                    case \"unless\":\n                    case \"while\":\n                    case \"until\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                        if (!checkToken.test(line)) {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"when\":\n                        if (/\\sthen\\s/.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                }\n\n                if (level > 0) {\n                    stack.unshift(token.value);\n                } else if (level <= 0 && ignore === false) {\n                    stack.shift();\n                    if (!stack.length) {\n                        if ((val == \"while\" || val == \"until\" || val == \"for\") && token.value != \"do\") {\n                            break;\n                        }\n                        if (token.value == \"do\" && dir == -1 && level != 0)\n                            break;\n                        if (token.value != \"do\")\n                            break;\n                    }\n\n                    if (level === 0) {\n                        stack.unshift(token.value);\n                    }\n                }\n            }\n        }\n\n        if (!token)\n            return null;\n\n        if (tokenRange) {\n            ranges.push(stream.getCurrentTokenRange());\n            return ranges;\n        }\n\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1) {\n            if (token.type === \"comment.multiline\") {\n                var endColumn = 6;\n            } else {\n                var endColumn = session.getLine(row).length;\n            }\n            return new Range(row, endColumn, startRow - 1, startColumn);\n        } else\n            return new Range(startRow, startColumn, row - 1, session.getLine(row - 1).length);\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/ruby\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/ruby_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/range\",\"ace/mode/behaviour/cstyle\",\"ace/mode/folding/ruby\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar RubyHighlightRules = require(\"./ruby_highlight_rules\").RubyHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar Range = require(\"../range\").Range;\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\nvar FoldMode = require(\"./folding/ruby\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = RubyHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = new CstyleBehaviour();\n    this.foldingRules = new FoldMode();\n    this.indentKeywords = this.foldingRules.indentKeywords;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n\n    this.lineCommentStart = \"#\";\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n\n        if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n            var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n            var startingConditional = line.match(/^\\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\\s*/);\n            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n                indent += tab;\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return /^\\s+(end|else|rescue|ensure)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, session, row) {\n        var line = session.getLine(row);\n        if (/}/.test(line))\n            return this.$outdent.autoOutdent(session, row);\n        var indent = this.$getIndent(line);\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine);\n        var tab = session.getTabString();\n        if (prevIndent.length <= indent.length) {\n            if (indent.slice(-tab.length) == tab)\n                session.remove(new Range(row, indent.length - tab.length, row, indent.length));\n        }\n    };\n\n    this.getMatching = function(session, row, column) {\n        if (row == undefined) {\n            var pos = session.selection.lead;\n            column = pos.column;\n            row = pos.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        if (startToken && startToken.value in this.indentKeywords)\n            return this.foldingRules.rubyBlock(session, row, column, true);\n    };\n\n    this.$id = \"ace/mode/ruby\";\n    this.snippetFileId = \"ace/snippets/ruby\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});                (function() {\n                    ace.require([\"ace/mode/ruby\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "],"sourceRoot":""}