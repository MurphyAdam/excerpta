{"version":3,"sources":["../node_modules/ace-builds/src-noconflict/mode-lua.js"],"names":["ace","define","require","exports","module","oop","TextHighlightRules","LuaHighlightRules","keywordMapper","this","createKeywordMapper","$rules","stateName","onMatch","value","currentState","stack","unshift","next","length","regex","shift","defaultToken","token","integer","normalizeRules","inherits","BaseFoldMode","FoldMode","Range","TokenIterator","foldingStartMarker","foldingStopMarker","getFoldWidget","session","foldStyle","row","line","getLine","isStart","test","isEnd","match","getTokenAt","index","type","bgTokenizer","getState","getFoldWidgetRange","doc","exec","luaBlock","getCommentFoldRange","openingBracketBlock","closingBracketBlock","column","tokenRange","stream","indentKeywords","getCurrentToken","val","dir","startColumn","getCurrentTokenColumn","startRow","step","stepBackward","stepForward","level","getCurrentTokenRange","getCurrentTokenRow","call","prototype","TextMode","Mode","LuaFoldMode","WorkerClient","HighlightRules","foldingRules","$behaviour","$defaultBehaviour","lineCommentStart","blockComment","start","end","outdentKeywords","getNextLineIndent","state","tab","indent","$getIndent","tokens","getTokenizer","getLineTokens","i","getNetIndentLevel","substr","checkOutdent","input","trim","indexOf","getMatching","undefined","pos","selection","lead","startToken","autoOutdent","startRange","replace","outdentRows","createWorker","worker","attachToDocument","getDocument","on","e","setAnnotations","data","clearAnnotations","$id","snippetFileId","m"],"mappings":"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","file":"static/js/86.6d395963.chunk.js","sourcesContent":["ace.define(\"ace/mode/lua_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar LuaHighlightRules = function() {\n\n    var keywords = (\n        \"break|do|else|elseif|end|for|function|if|in|local|repeat|\"+\n         \"return|then|until|while|or|and|not\"\n    );\n\n    var builtinConstants = (\"true|false|nil|_G|_VERSION\");\n\n    var functions = (\n        \"string|xpcall|package|tostring|print|os|unpack|require|\"+\n        \"getfenv|setmetatable|next|assert|tonumber|io|rawequal|\"+\n        \"collectgarbage|getmetatable|module|rawset|math|debug|\"+\n        \"pcall|table|newproxy|type|coroutine|_G|select|gcinfo|\"+\n        \"pairs|rawget|loadstring|ipairs|_VERSION|dofile|setfenv|\"+\n        \"load|error|loadfile|\"+\n\n        \"sub|upper|len|gfind|rep|find|match|char|dump|gmatch|\"+\n        \"reverse|byte|format|gsub|lower|preload|loadlib|loaded|\"+\n        \"loaders|cpath|config|path|seeall|exit|setlocale|date|\"+\n        \"getenv|difftime|remove|time|clock|tmpname|rename|execute|\"+\n        \"lines|write|close|flush|open|output|type|read|stderr|\"+\n        \"stdin|input|stdout|popen|tmpfile|log|max|acos|huge|\"+\n        \"ldexp|pi|cos|tanh|pow|deg|tan|cosh|sinh|random|randomseed|\"+\n        \"frexp|ceil|floor|rad|abs|sqrt|modf|asin|min|mod|fmod|log10|\"+\n        \"atan2|exp|sin|atan|getupvalue|debug|sethook|getmetatable|\"+\n        \"gethook|setmetatable|setlocal|traceback|setfenv|getinfo|\"+\n        \"setupvalue|getlocal|getregistry|getfenv|setn|insert|getn|\"+\n        \"foreachi|maxn|foreach|concat|sort|remove|resume|yield|\"+\n        \"status|wrap|create|running|\"+\n        \"__add|__sub|__mod|__unm|__concat|__lt|__index|__call|__gc|__metatable|\"+\n         \"__mul|__div|__pow|__len|__eq|__le|__newindex|__tostring|__mode|__tonumber\"\n    );\n\n    var stdLibaries = (\"string|package|os|io|math|debug|table|coroutine\");\n\n    var deprecatedIn5152 = (\"setn|foreach|foreachi|gcinfo|log10|maxn\");\n\n    var keywordMapper = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"support.function\": functions,\n        \"keyword.deprecated\": deprecatedIn5152,\n        \"constant.library\": stdLibaries,\n        \"constant.language\": builtinConstants,\n        \"variable.language\": \"self\"\n    }, \"identifier\");\n\n    var decimalInteger = \"(?:(?:[1-9]\\\\d*)|(?:0))\";\n    var hexInteger = \"(?:0[xX][\\\\dA-Fa-f]+)\";\n    var integer = \"(?:\" + decimalInteger + \"|\" + hexInteger + \")\";\n\n    var fraction = \"(?:\\\\.\\\\d+)\";\n    var intPart = \"(?:\\\\d+)\";\n    var pointFloat = \"(?:(?:\" + intPart + \"?\" + fraction + \")|(?:\" + intPart + \"\\\\.))\";\n    var floatNumber = \"(?:\" + pointFloat + \")\";\n\n    this.$rules = {\n        \"start\" : [{\n            stateName: \"bracketedComment\",\n            onMatch : function(value, currentState, stack){\n                stack.unshift(this.next, value.length - 2, currentState);\n                return \"comment\";\n            },\n            regex : /\\-\\-\\[=*\\[/,\n            next  : [\n                {\n                    onMatch : function(value, currentState, stack) {\n                        if (value.length == stack[1]) {\n                            stack.shift();\n                            stack.shift();\n                            this.next = stack.shift();\n                        } else {\n                            this.next = \"\";\n                        }\n                        return \"comment\";\n                    },\n                    regex : /\\]=*\\]/,\n                    next  : \"start\"\n                }, {\n                    defaultToken : \"comment\"\n                }\n            ]\n        },\n\n        {\n            token : \"comment\",\n            regex : \"\\\\-\\\\-.*$\"\n        },\n        {\n            stateName: \"bracketedString\",\n            onMatch : function(value, currentState, stack){\n                stack.unshift(this.next, value.length, currentState);\n                return \"string.start\";\n            },\n            regex : /\\[=*\\[/,\n            next  : [\n                {\n                    onMatch : function(value, currentState, stack) {\n                        if (value.length == stack[1]) {\n                            stack.shift();\n                            stack.shift();\n                            this.next = stack.shift();\n                        } else {\n                            this.next = \"\";\n                        }\n                        return \"string.end\";\n                    },\n                    \n                    regex : /\\]=*\\]/,\n                    next  : \"start\"\n                }, {\n                    defaultToken : \"string\"\n                }\n            ]\n        },\n        {\n            token : \"string\",           // \" string\n            regex : '\"(?:[^\\\\\\\\]|\\\\\\\\.)*?\"'\n        }, {\n            token : \"string\",           // ' string\n            regex : \"'(?:[^\\\\\\\\]|\\\\\\\\.)*?'\"\n        }, {\n            token : \"constant.numeric\", // float\n            regex : floatNumber\n        }, {\n            token : \"constant.numeric\", // integer\n            regex : integer + \"\\\\b\"\n        }, {\n            token : keywordMapper,\n            regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n        }, {\n            token : \"keyword.operator\",\n            regex : \"\\\\+|\\\\-|\\\\*|\\\\/|%|\\\\#|\\\\^|~|<|>|<=|=>|==|~=|=|\\\\:|\\\\.\\\\.\\\\.|\\\\.\\\\.\"\n        }, {\n            token : \"paren.lparen\",\n            regex : \"[\\\\[\\\\(\\\\{]\"\n        }, {\n            token : \"paren.rparen\",\n            regex : \"[\\\\]\\\\)\\\\}]\"\n        }, {\n            token : \"text\",\n            regex : \"\\\\s+|\\\\w+\"\n        } ]\n    };\n    \n    this.normalizeRules();\n};\n\noop.inherits(LuaHighlightRules, TextHighlightRules);\n\nexports.LuaHighlightRules = LuaHighlightRules;\n});\n\nace.define(\"ace/mode/folding/lua\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\n\nvar FoldMode = exports.FoldMode = function() {};\n\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n    this.foldingStartMarker = /\\b(function|then|do|repeat)\\b|{\\s*$|(\\[=*\\[)/;\n    this.foldingStopMarker = /\\bend\\b|^\\s*}|\\]=*\\]/;\n\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n\n        if (isStart && !isEnd) {\n            var match = line.match(this.foldingStartMarker);\n            if (match[1] == \"then\" && /\\belseif\\b/.test(line))\n                return;\n            if (match[1]) {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return \"start\";\n            } else if (match[2]) {\n                var type = session.bgTokenizer.getState(row) || \"\";\n                if (type[0] == \"bracketedComment\" || type[0] == \"bracketedString\")\n                    return \"start\";\n            } else {\n                return \"start\";\n            }\n        }\n        if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd)\n            return \"\";\n\n        var match = line.match(this.foldingStopMarker);\n        if (match[0] === \"end\") {\n            if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                return \"end\";\n        } else if (match[0][0] === \"]\") {\n            var type = session.bgTokenizer.getState(row - 1) || \"\";\n            if (type[0] == \"bracketedComment\" || type[0] == \"bracketedString\")\n                return \"end\";\n        } else\n            return \"end\";\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1])\n                return this.luaBlock(session, row, match.index + 1);\n\n            if (match[2])\n                return session.getCommentFoldRange(row, match.index + 1);\n\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[0] === \"end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return this.luaBlock(session, row, match.index + 1);\n            }\n\n            if (match[0][0] === \"]\")\n                return session.getCommentFoldRange(row, match.index + 1);\n\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n\n    this.luaBlock = function(session, row, column, tokenRange) {\n        var stream = new TokenIterator(session, row, column);\n        var indentKeywords = {\n            \"function\": 1,\n            \"do\": 1,\n            \"then\": 1,\n            \"elseif\": -1,\n            \"end\": -1,\n            \"repeat\": 1,\n            \"until\": -1\n        };\n\n        var token = stream.getCurrentToken();\n        if (!token || token.type != \"keyword\")\n            return;\n\n        var val = token.value;\n        var stack = [val];\n        var dir = indentKeywords[val];\n\n        if (!dir)\n            return;\n\n        var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n        var startRow = row;\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        while(token = stream.step()) {\n            if (token.type !== \"keyword\")\n                continue;\n            var level = dir * indentKeywords[token.value];\n\n            if (level > 0) {\n                stack.unshift(token.value);\n            } else if (level <= 0) {\n                stack.shift();\n                if (!stack.length && token.value != \"elseif\")\n                    break;\n                if (level === 0)\n                    stack.unshift(token.value);\n            }\n        }\n\n        if (!token)\n            return null;\n\n        if (tokenRange)\n            return stream.getCurrentTokenRange();\n\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1)\n            return new Range(row, session.getLine(row).length, startRow, startColumn);\n        else\n            return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/lua\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/lua_highlight_rules\",\"ace/mode/folding/lua\",\"ace/range\",\"ace/worker/worker_client\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar LuaHighlightRules = require(\"./lua_highlight_rules\").LuaHighlightRules;\nvar LuaFoldMode = require(\"./folding/lua\").FoldMode;\nvar Range = require(\"../range\").Range;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\n\nvar Mode = function() {\n    this.HighlightRules = LuaHighlightRules;\n    \n    this.foldingRules = new LuaFoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n   \n    this.lineCommentStart = \"--\";\n    this.blockComment = {start: \"--[\", end: \"]--\"};\n    \n    var indentKeywords = {\n        \"function\": 1,\n        \"then\": 1,\n        \"do\": 1,\n        \"else\": 1,\n        \"elseif\": 1,\n        \"repeat\": 1,\n        \"end\": -1,\n        \"until\": -1\n    };\n    var outdentKeywords = [\n        \"else\",\n        \"elseif\",\n        \"end\",\n        \"until\"\n    ];\n\n    function getNetIndentLevel(tokens) {\n        var level = 0;\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (token.type == \"keyword\") {\n                if (token.value in indentKeywords) {\n                    level += indentKeywords[token.value];\n                }\n            } else if (token.type == \"paren.lparen\") {\n                level += token.value.length;\n            } else if (token.type == \"paren.rparen\") {\n                level -= token.value.length;\n            }\n        }\n        if (level < 0) {\n            return -1;\n        } else if (level > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n        var level = 0;\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n\n        if (state == \"start\") {\n            level = getNetIndentLevel(tokens);\n        }\n        if (level > 0) {\n            return indent + tab;\n        } else if (level < 0 && indent.substr(indent.length - tab.length) == tab) {\n            if (!this.checkOutdent(state, line, \"\\n\")) {\n                return indent.substr(0, indent.length - tab.length);\n            }\n        }\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        if (input != \"\\n\" && input != \"\\r\" && input != \"\\r\\n\")\n            return false;\n\n        if (line.match(/^\\s*[\\)\\}\\]]$/))\n            return true;\n\n        var tokens = this.getTokenizer().getLineTokens(line.trim(), state).tokens;\n\n        if (!tokens || !tokens.length)\n            return false;\n\n        return (tokens[0].type == \"keyword\" && outdentKeywords.indexOf(tokens[0].value) != -1);\n    };\n\n    this.getMatching = function(session, row, column) {\n        if (row == undefined) {\n            var pos = session.selection.lead;\n            column = pos.column;\n            row = pos.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        if (startToken && startToken.value in indentKeywords)\n            return this.foldingRules.luaBlock(session, row, column, true);\n    };\n\n    this.autoOutdent = function(state, session, row) {\n        var line = session.getLine(row);\n        var column = line.match(/^\\s*/)[0].length;\n        if (!column || !row) return;\n\n        var startRange = this.getMatching(session, row, column + 1);\n        if (!startRange || startRange.start.row == row)\n             return;\n        var indent = this.$getIndent(session.getLine(startRange.start.row));\n        if (indent.length != column) {\n            session.replace(new Range(row, 0, row, column), indent);\n            session.outdentRows(new Range(row + 1, 0, row + 1, 0));\n        }\n    };\n\n    this.createWorker = function(session) {\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/lua_worker\", \"Worker\");\n        worker.attachToDocument(session.getDocument());\n        \n        worker.on(\"annotate\", function(e) {\n            session.setAnnotations(e.data);\n        });\n        \n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n        \n        return worker;\n    };\n\n    this.$id = \"ace/mode/lua\";\n    this.snippetFileId = \"ace/snippets/lua\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});                (function() {\n                    ace.require([\"ace/mode/lua\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "],"sourceRoot":""}